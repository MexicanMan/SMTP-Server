\documentclass[a4paper,12pt]{report}

\input{header.tex}


\title{Расчетно-Пояснительная Записка \\ 
    \large к курсовой работе на тему: \\ Серверная часть MTA SMTP}
\author{Назаренко Никита Вадимович}

\begin{document}

\maketitle


\tableofcontents

\newpage
\addcontentsline{toc}{chapter}{Введение}
\chapter*{Введение}

Данная расчетно-пояснительная записка содержит информацию о протоколе SMTP (англ. \textbf{S}imple \textbf{M}ail \textbf{T}ransfer \textbf{P}rotocol) и реализации серверной части MTA (англ. \textbf{M}essage \textbf{T}ransfer \textbf{A}gent) SMTP в рамках курсового работа.

Задание: необходимо было создать SMTP-сервер, как часть MTA, обеспечивающий локальную доставку сообщений и их добавление в очередь удаленной доставки для клиента. Дополнительные условия:
\begin{itemize}
\item Используется poll;
\item Используется единственный рабочий поток;
\item Журналирование в отдельном процессе.
\end{itemize}

Цель работы: реализовать серверную часть MTA SMTP.

Основные задачи:
\begin{enumerate}
    \item Анализ и изучение протокола SMTP, способов мультиплексирования;
    \item Программная реализация SMTP сервера на языке программирования Си под Unix-подобные операционные системы;
    \item Тестирование и отладка написанного сервера;
    \item Оформление расчетно-пояснительной записки по результатам работы.
\end{enumerate}


\chapter{Аналитический раздел}


\section{Протокол SMTP}

SMTP (англ. \textbf{S}imple \textbf{M}ail \textbf{T}ransfer \textbf{P}rotocol) ~-- это широко используемый сетевой протокол, предназначенный для передачи писем электронной почты в сетях TCP/IP. SMTP впервые был описан в RFC 821 (1982 год), а последнее обновление описано в RFC 5321 (2008 год) и включает масштабируемое расширение протокола — ESMTP (Extended SMTP). В настоящее время под протоколом SMTP подразумеваются и его расширения. Протокол SMTP предназначен для передачи исходящей почты с использованием порта TCP 25.

Взаимодействие в рамках SMTP строится по принципу двусторонней связи, которая устанавливается между отправителем и получателем почтового сообщения. При этом отправитель инициирует соединение и посылает запросы, а получатель - отвечает на эти запросы. Таким образом, отправитель выступает в роли клиента, а получатель - сервера.


\subsection{Базовые команды SMTP}

Каждая команда SMTP начинается с ключевого слова – названия команды, указывающего какую операцию хочет произвести клиент. За ним могут следовать параметры, отделенные пробелом. Конец строк в протоколе SMTP обозначается последовательностью символов "возврат каретки"\ (\textbackslash r) и "перевод строки"\ (\textbackslash n) - эта последовательность обозначается CRLF. Сервер начинает выполнение команды только получив от клиента строку, завершающуюся последовательностью CRLF. 

Обычный ответ SMTP сервера на команды клиента состоит из номера ответа, за которым через пробел следует дополнительный текст. Номер ответа служит индикатором состояния сервера и делится на четыре группы:
\begin{itemize}
    \item Команда выполнена успешно (код 2xx);
    \item ромежуточный положительный результат. Команда принята, но сервер ожидает от клиента дополнительные данные для завершения операции (код 3xx);
    \item Исполнение команды временно невозможно. Команда не может быть выполнена, но проблема может быть устранена (код 4xx);
    \item Исполнение команды невозможно (код 5xx).
\end{itemize}

Если ответ состоит из нескольких строк, то каждая из них начинается номером, который отделяется от сопровождающего текста не пробелом, а символом "минус"\ (-). В последней строке номер отделяется от текста пробелом. Каждая строка ответа, как и строки команд, заканчивается последовательностью CRLF.

Ниже представлен список базовых SMTP-команд:
\begin{itemize}
    \item EHLO доменное\_имя\_клиента CRLF - Открывает ESMTP сессию. В ответ на эту команду сервер сообщает, готов ли он к продолжению диалога.
    \item HELO доменное\_имя\_клиента CRLF - Открывает SMTP сессию. В RFC 2821 рекомендуется использовать команду HELO, только если программное обеспечение не поддерживает команду EHLO. Отличие этой команды только в том, что она делает невозможным использование расширений ESMTP. Передача почты возможна только после выполнения одной из двух перечисленных выше команд.
    \item MAIL FROM: <адрес\_отправителя> CRLF - Сообщает адрес отправителя письма. Для каждого письма команда MAIL должна быть выполнена только один раз. Адрес может быть оставлен пустым: <>. Команда MAIL может быть выполнена только после успешного выполнения команды EHLO или HELO.
    \item RCPT TO: <адрес\_получателя> CRLF - Сообщает адрес получателя письма. Доставка сообщения возможна, только если указан хотя бы один адрес получателя. Команда RCPT принимает в качестве аргумента только один адрес. Если нужно послать письмо большему числу адресатов, то команду RCPT следует повторять для каждого. Команда RCPT может быть выполнена только после успешного выполнения команды MAIL.
    \item DATA CRLF - Определяет начало письма. C помощью этой команды серверу передается текст сообщения, состоящий из заголовка и отделенного от него пустой строкой тела сообщения. В ответ на правильно введенную команду DATA сервер сообщает о готовности к приему или об ошибке, если прием сообщения невозможен. Передача самого сообщения заканчивается строкой, состоящей из одной точки. Эта строка не является частью сообщения и удаляется на приемной стороне. Команда DATA может быть выполнена только после успешного выполнения хотя бы одной команды RCPT.
    \item RSET CRLF - Сброс SMTP соединения. Команда RSET аннулирует все переданные до нее на сервер данные.
    \item VRFY CRLF - Проверяет наличия указанного в качестве аргумента почтового ящика.
    \item QUIT CRLF - Закрыть SMTP сессию. Командой QUIT клиент заканчивает диалог с сервером. Сервер посылает подтверждение и закрывает соединение. Получив это подтверждение, клиент тоже прекращает связь.
\end{itemize}

\section{Плюсы и минусы использования однопоточного подхода обработки подключений при помощи мультиплексирования и системного вызова poll()}

В рамках задания необходимо реализовать серверную часть MTA SMTP с использованием системного вызова \texttt{poll()} в единственном рабочем потоке. К плюсам данного подхода можно отнести:
\begin{itemize}
    \item Нет нужды создавать новые процессы или потоки, что является затратной операцией для ОС.
    \item Нет активного ожидания на процессоре.
    \item Все взаимодействие с сокетами осуществляется в одном потоке выполнения, что снимает необходимость синхронизации доступа к разделяемым ресурсам.
    \item Позволяет обрабатывать больше 1024 клиентов по сравнению с системным вызовом \texttt{select()}.
\end{itemize}

К минусам использования этого подхода относятся:
\begin{itemize}
    \item Усложняется работа с памятью, так как \texttt{poll()} может потребовать использование динамических массивов.
    \item В полностью однопоточном подходе может увеличится время обработки каждого подключения при больших количествах активных соединений по сравнению с подходом в несколько потоков.
\end{itemize}


\section{Сущности предметной области}

Для SMTP сервера можно выделить две основные сущности, которыми необходимо оперировать (обрабатывать, сохранять):
\begin{enumerate}
    \item Клиент - текущее активное соединение с информацией о подключении (буферы ввода-вывода, длина, состояние)
    \item Письмо - передаваемое клиентом сообщение на сервер с заголовками (отправитель, получатель, тема и т.д.) и данными (сам текст письма).
\end{enumerate}


\chapter{Конструкторский раздел}


\section{Конечный автомат состояний сервера}

На рис.~\ref{fig:fsm} изображен конечный автомат состояний серверной части MTA SMTP. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{include/server_def_dot.pdf}
    \caption{Конечный автомат состояний сервера}
    \label{fig:fsm}
\end{figure}

Как можно заметить, команды, связанные с отправкой сообщения (например, MAIL), могут обрабатываться только после вызова HELO или EHLO. Соответственно RCPT может вызываться только после MAIL, а DATA только после RCPT. После вызова DATA ожидается окончание письма, для его сохранения и записи. По остальным командам особых ограничений не имеется. 

В случае продолжительного бейздействия клиента (ничего не отправляется заданное заранее время), сервер обрывает соединение по таймауту с уведомлением об этом клиента.


\section{Синтаксис команд протокола}

Ниже приведены регулярные выражения всех использующихся команд протокола и вспомогательные регулярные выражения, использующиеся в них:
\begin{description}
    \item[Возможные символы пробела]
    \input{include/spaces_regexp.tex}
    \item[Домен]
    \input{include/domain_regexp.tex}
    \item[Почтовый адрес]
    \input{include/address_regexp.tex}
    \item[Почтовый адрес или пустой адрес]
    \input{include/address_or_empty_regexp.tex}
    \item[Конец строки (CLRF)]
    \textbackslash r\textbackslash n
    \item[Команда HELO]
    \input{include/helo_cmd_regexp.tex}
    \item[Команда EHLO]
    \input{include/ehlo_cmd_regexp.tex}
    \item[Команда MAIL]
    \input{include/mail_cmd_regexp.tex}
    \item[Команда RCPT]
    \input{include/rcpt_cmd_regexp.tex}
    \item[Команда DATA]
    \input{include/data_cmd_regexp.tex}
    \item[Команда RSET]
    \input{include/rset_cmd_regexp.tex}
    \item[Команда VRFY]
    \input{include/vrfy_cmd_regexp.tex}
    \item[Команда QUIT]
    \input{include/quit_cmd_regexp.tex}
\end{description}


\section{Описание основных структур данных}

На рис.~\ref{fig:er} изображены основные структуры данных сервера, а именно:
\begin{itemize}
    \item Server - абстракция сервера, содержащая в себе словарь клиентов, дескрипторы их сокетов и таймауты, а также справочную информацию (доменное имя сервера, пути до папок с письмами).
    \item Client dictionary - словарь клиентов. В качестве ключа используется номер файлового дескриптора сокета клиента.
    \item Client - абстракция клиента, содержащая в себе буферы ввода-вывода, их длины, текущее состояние подключения клиента и текущее письмо.
    \item Mail - абстракция письма. Состоит из полей отправителя, данных (текста письма), массива получателей, их количества и типа (получатели только локальные, только удаленные или оба).
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{pics/er.pdf}
    \caption{ER-диаграмма основных структур данных}
    \label{fig:er}
\end{figure}


\section{Обработка соединений в одном потоке выполнения}

Ниже представлен псевдокод обработки сервером клиентских соединений в одном потоке выполнения:

\begin{verbatim}
    Если пришло сообщение в файловый дескриптор для выхода
        Выйти
    
    Если пришло сообщение на сокет сервера 
        Обработать новое подключение и добавить нового клиента
    
    Цикл по всем дескрипторам сокетов клиента
        Если пришло сообщение на сокет клиента
            Обнулить таймер клиента
            Обработать сообщение от клиента
        Если нужно отправить сообщение клиенту
            Отослать сообщение клиенту

    Увеличить таймер всех клиентов на 1
    Если таймер клиента превысил определенное заданное значение
        Оборвать соединение с клиентом
\end{verbatim}


\section{Связь основной программы и процесса журналирования}

На рис.~\ref{fig:ipc} изображена связь между основной программой и процессом журналирования с использованием очереди сообщений.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{pics/ipc.pdf}
    \caption{Связь основной программы и процесса журналирования}
    \label{fig:ipc}
\end{figure}


\section{Хранение почты}

Для хранения локальной почты, то есть предназначенной для клиентов с почтовым доменом сервера, используется упрощенный формат Maildir. Maildir - формат хранения электронной почты, не требующий монопольного захвата файла для обеспечения целостности почтового ящика при чтении, добавлении или изменении сообщений. Каждое сообщение хранится в отдельном файле с уникальным именем, а каждая папка представляет собой каталог. Вопросами блокировки файлов при добавлении, перемещении и удалении файлов занимается локальная файловая система. Все изменения делаются при помощи атомарных файловых операций, таким образом, монопольный захват файла ни в каком случае не нужен.

Для почты, предназначенной другим почтовым серверам также используется файловая система. Каждое сообщение аналогично хранится в отдельном файле с уникальным именем. Все файлы складываются в одну директорию, из которой в дальнейшем клиент считывает письма для их пересылки. 

Для того, чтобы имена файлов были уникальными, в их качестве используется слегка измененный формат Unix time (рус. Unix-время) - система описания моментов во времени, принятая в Unix и других POSIX-совместимых операционных системах. В отличие от оригинального Unix time в данной работе вместо секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года, используются миллисекундыя, так как секунд недостаточно для удостоверения уникальности имени файла.


\chapter{Технологический раздел}


\section{Платформы и компиляторы}

Разработанное приложение SMTP сервера проверялось на операционной системе Ubuntu-20.04 в подсистеме WSL (англ. \textbf{W}indows \textbf{S}ybsystem \textbf{L}inux) с использованием компилятора GCC и стандарта языка Си C99.


\section{Сборка программы}

Сборка системы разделена на две части и описана в файлах \texttt{Makefile} системы сборки \texttt{make}.

Первая часть, верхнеуровневая, описывает описывает сборку всего MTA, включая и серверную часть и клиентскую. Однако также можно указать сборку только одной части. В данном файле указываются флаги для сборки сервера и клиента, а также директория, где будут лежать запускамые бирнарные файлы. В качестве аргумента при вызове \texttt{make} принимается параметр \texttt{build\_type}, который может быть равен \texttt{debug} или \texttt{release}. По умолчанию стоит \texttt{debug}. Пример вызовов:
\begin{verbatim}
    make server
    make build_type=release
\end{verbatim}

Вторая часть относится непосредственно к сборке приложения сервера и запуску тестов и вызывается из верхнеуровнего файла сборки. В этом файле указываются имя результирующего бинарного файла, флаги компилятора, линковщика и папки с исходным кодом программы. Все зависимости \texttt{make} ищет сам в рамках указанных папок.


\section{Основные функции программы}

Данный раздел сгеренерирован при помощи doxygen из части комментированных исходников программы. В файле конфигурации \textbf{doxyggen.cfg} был отключён параметр \textbf{HAVE\_DOT}, поскольку для рисования графов вызовов используется \textit{cflow}.

Здесь описываются основные функции сервера, отвечающие за его работоспособность.

\input{include/main_8c.tex}
\input{include/server_8h.tex}


\section{Основные структуры программы}

Данный раздел также как и прошлый сгеренерирован при помощи doxygen и описывает основные структуры, использующиеся в коде сервера и на которые ссылаются его основные функции.

\input{include/structserver__struct.tex}
\input{include/structserver__client__dict__struct.tex}
\input{include/structserver__client__struct.tex}
\input{include/structmail__struct.tex}


\section{Описание параметров командной строки}

Ниже приведено описание используемых сервером обязательных и необязательных параметров командной строки в формате autoopts:
\input{include/server-opts.def.tex}


\section{Графы вызова функций}

Графы вызова функций разбиты на два рисунка. Ниже на рис.~\ref{fig:cflow1} показаны основные функции, связанные с работоспособностью сервера. На рис.~\ref{fig:cflow2} в свою очередь показаны функции обработки команд от клиента и конечного автомата состояний сервера.

\begin{figure}[h]
\includegraphics[width=1.1\textwidth]{include/cflow_main_dot.pdf}
\caption{Граф вызовов. Основные функции}
\label{fig:cflow1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/cflow_handlers_dot.pdf}
\caption{Граф вызовов. Функции обработки команд}
\label{fig:cflow2}
\end{figure}

Сами графы были созданы с помощью утилит \texttt{cflow}, \texttt{cflow2dot} и \texttt{dot}.


\section{Модульное тестирование}

Для модульного тестирования функций сервера в работе используется библиотека CUnit. Тестировались все основные модули, такие как: модуль писем, клиентов, парсера команд, сервера и обработчика команд от клиента. Для каждого из них было написано несколько тестов с ассертами. Ниже приведены сводные результаты тестирования:
\begin{verbatim}
    Run Summary:    Type  Total    Ran Passed Failed Inactive
              suites      5      5    n/a      0        0
               tests     21     21     21      0        0
             asserts     87     87     87      0      n/a

    Elapsed time =    0.011 seconds
\end{verbatim}


\section{Системное тестирование}

Для системного тестирования был написан скрипт на языке Python с использованием библиотеки \texttt{smtplib}. Данный скрипт подключается к запущенному серверу, а затем отсылает несколько сообщений на него при помощи функции библиотеки \texttt{sendmail(from, to, msg)}. Если все сообщения отправились успешно, то в конце работы скрипт выводит на экран фразу \texttt{"All OK!"}.

Код самого скрипта на языке Python приведен ниже:
\input{include/sys_test_py.tex}


\section{Тестирование утечек памяти}

Для тестирования утечек памяти использовалась утилита valgrind. По результатам тестов, при помощи описанного выше скрипта, она не обнаружила никаких потенциально возможных мест с утечками памяти. Окончательные результаты ее работы приведены ниже:
\begin{verbatim}
    ==15099== HEAP SUMMARY:
    ==15099==     in use at exit: 0 bytes in 0 blocks
    ==15099==   total heap usage: 139 allocs, 139 frees, 1,981,144 bytes allocated
    ==15099== 
    ==15099== All heap blocks were freed -- no leaks are possible
\end{verbatim}


\newpage
\addcontentsline{toc}{chapter}{Заключение}
\chapter*{Заключение}

В процессе выполнения работы была написана программная реализация серверной части MTA SMTP. Был изучен протокол передачи электронной почты SMTP и способы мультиплексирования. Были закреплены и получены навыки в написании сетевых приложений на языке Си для Unix-подобных операционных систем. Было проведено тестирование и отладка разработанного серверного приложения и в итоге по результатам проведенной работы была оформлена расчетно-пояснительная записка.


\end{document}
